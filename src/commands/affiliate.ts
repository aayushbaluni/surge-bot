import { Telegraf } from 'telegraf';
import { Context } from '../types';
import { User, AffiliateReward } from '../database';
import { logger } from '../utils/logger';
import { ADMIN_CHAT_ID } from '../config/env';

export function setupAffiliateCommands(bot: Telegraf<Context>) {
  logger.info('Setting up affiliate commands...');

  // Handle /affiliate command
  bot.command('affiliate', async (ctx) => {
    logger.info('Affiliate command received', {
      userId: ctx.from?.id,
      username: ctx.from?.username
    });

    try {
      if (!ctx.from) {
        logger.error('No user context in affiliate command');
        await ctx.reply('Error: Could not identify user.');
        return;
      }

      // Check if user exists in database
      let user = await User.findOne({ userId: ctx.from.id });
      logger.info('User lookup result:', { 
        userId: ctx.from.id, 
        exists: !!user,
        userData: user ? {
          subscription: user.subscription,
          tvUsername: user.tvUsername
        } : null
      });

      if (!user) {
        logger.info('Creating new user for affiliate command', { userId: ctx.from.id });
        user = new User({
          userId: ctx.from.id,
          username: ctx.from.username,
          firstName: ctx.from.first_name,
          lastName: ctx.from.last_name,
          subscription: {
            isActive: false,
            plan: null,
            startDate: null,
            endDate: null
          },
          affiliateStats: {
            totalEarnings: 0,
            pendingEarnings: 0,
            totalAffiliates: 0,
            successfulAffiliates: 0
          }
        });
        await user.save();
        logger.info('New user created successfully', { 
          userId: ctx.from.id,
          userData: {
            subscription: user.subscription,
            tvUsername: user.tvUsername
          }
        });
      }

      logger.info('User data for affiliate command:', {
        userId: ctx.from.id,
        hasAffiliateCode: user?.affiliateCode ? 'yes' : 'no'
      });

      if (!user.affiliateCode) {
        logger.info('Generating new affiliate code for user');
        // The code will be generated by the pre-save hook
        await user.save();
      }

      const pendingRewards = await AffiliateReward.find({
        userId: ctx.from.id,
        status: 'pending'
      });

      const totalPending = pendingRewards.reduce((sum: number, reward: { amount: number }) => sum + reward.amount, 0);

      const affiliateMessage = `ðŸŽ¯ Your Affiliate Program

Your Affiliate Code: <code>${user.affiliateCode}</code>

Share your affiliate link:
https://t.me/${ctx.botInfo.username}?start=${user.affiliateCode}

ðŸ“Š Your Affiliate Stats:
â€¢ Total Earnings: ${user.affiliateStats?.totalEarnings || 0} SOL
â€¢ Pending Earnings: ${totalPending} SOL
â€¢ Total Affiliates: ${user.affiliateStats?.totalAffiliates || 0}
â€¢ Successful Affiliates: ${user.affiliateStats?.successfulAffiliates || 0}

ðŸ’° You earn 10% of every successful purchase made through your affiliate link!`;

      logger.info('Sending affiliate message', { 
        userId: ctx.from.id,
        hasKeyboard: true,
        pendingRewards: pendingRewards.length,
        totalPending
      });

      await ctx.reply(affiliateMessage, {
        parse_mode: 'HTML',
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'ðŸ”™ Back to Subscription', callback_data: 'back_to_subscription' }
            ]
          ]
        }
      });
    } catch (error) {
      logger.error('Error in affiliate command:', error);
      await ctx.reply('Error processing affiliate command. Please try again later.');
    }
  });

  // Handle referral program button
  bot.action('referral_program', async (ctx) => {
    try {
      await ctx.answerCbQuery();
      await ctx.reply('Please use /referral to view your referral program details and stats.');
    } catch (error) {
      logger.error('Error in referral program action:', error);
      await ctx.reply('Sorry, there was an error. Please try again.');
    }
  });

  // Handle set wallet button
  bot.action('set_wallet', async (ctx) => {
    try {
      await ctx.answerCbQuery();
      await ctx.reply('Please send your Solana wallet address where you want to receive your referral rewards.');
      ctx.session.step = 'set_wallet';
    } catch (error) {
      logger.error('Error in set wallet action:', error);
      await ctx.reply('Sorry, there was an error. Please try again.');
    }
  });

  // Handle view rewards button
  bot.action('view_rewards', async (ctx) => {
    try {
      await ctx.answerCbQuery();
      const rewards = await AffiliateReward.find({ 
        userId: ctx.from.id,
        status: 'pending'
      }).sort({ createdAt: -1 });

      if (rewards.length === 0) {
        await ctx.reply('You have no pending rewards.');
        return;
      }

      let message = 'ðŸ’° Your Pending Rewards:\n\n';
      rewards.forEach((reward, index) => {
        message += `${index + 1}. ${reward.amount} SOL\n`;
        message += `   Date: ${reward.createdAt.toLocaleDateString()}\n\n`;
      });

      message += 'To receive your rewards, please set your wallet address using the "Set Wallet Address" button.';

      const keyboard = {
        inline_keyboard: [
          [{ text: 'ðŸ’³ Set Wallet Address', callback_data: 'set_wallet' }],
          [{ text: 'ðŸ”„ Back to Main Menu', callback_data: 'back_to_main' }]
        ]
      };

      await ctx.reply(message, { reply_markup: keyboard });
    } catch (error) {
      logger.error('Error in view rewards action:', error);
      await ctx.reply('Sorry, there was an error. Please try again.');
    }
  });

  // Handle wallet address input
  bot.hears(/^.+$/, async (ctx) => {
    try {
      if (ctx.session.step !== 'set_wallet') {
        return;
      }

      const walletAddress = ctx.message.text.trim();
      
      // Basic Solana address validation
      if (!/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(walletAddress)) {
        await ctx.reply('Invalid Solana wallet address. Please try again.');
        return;
      }

      await User.findOneAndUpdate(
        { userId: ctx.from.id },
        { walletAddress }
      );

      // Get pending rewards
      const pendingRewards = await AffiliateReward.find({
        userId: ctx.from.id,
        status: 'pending'
      });

      const totalPending = pendingRewards.reduce((sum: number, reward: { amount: number }) => sum + reward.amount, 0);

      const confirmationMessage = `âœ… Your wallet address has been saved!\n\nWallet: <code>${walletAddress}</code>\nPending Rewards: ${totalPending} SOL\n\nClick below to redeem your rewards:`;

      const keyboard = {
        inline_keyboard: [
          [{ text: 'ðŸ’° Redeem Rewards', callback_data: 'redeem_rewards' }],
          [{ text: 'ðŸ”„ Back to Main Menu', callback_data: 'back_to_main' }]
        ]
      };

      await ctx.reply(confirmationMessage, {
        parse_mode: 'HTML',
        reply_markup: keyboard
      });

      ctx.session.step = 'welcome';
    } catch (error) {
      logger.error('Error in wallet address input:', error);
      await ctx.reply('Sorry, there was an error. Please try again.');
    }
  });

  // Handle redeem rewards button
  bot.action('redeem_rewards', async (ctx) => {
    try {
      await ctx.answerCbQuery();
      
      const user = await User.findOne({ userId: ctx.from.id });
      if (!user?.walletAddress) {
        await ctx.reply('Please set your wallet address first using the "Set Wallet Address" button.');
        return;
      }

      const pendingRewards = await AffiliateReward.find({
        userId: ctx.from.id,
        status: 'pending'
      });

      if (pendingRewards.length === 0) {
        await ctx.reply('You have no pending rewards to redeem.');
        return;
      }

      const totalPending = pendingRewards.reduce((sum: number, reward: { amount: number }) => sum + reward.amount, 0);

      // Notify admin about redemption request
      if (ADMIN_CHAT_ID) {
        const adminMessage = `ðŸ”” New Rewards Redemption Request\n\nUser: @${user.username || 'unknown'}\nWallet: <code>${user.walletAddress}</code>\nTotal Amount: ${totalPending} SOL\n\nClick below to process rewards:`;

        const keyboard = {
          inline_keyboard: [
            [{ text: 'ðŸ’¸ Process Rewards', callback_data: `process_rewards_${ctx.from.id}` }]
          ]
        };

        await ctx.telegram.sendMessage(ADMIN_CHAT_ID, adminMessage, {
          parse_mode: 'HTML',
          reply_markup: keyboard
        });
      }

      await ctx.reply('âœ… Your redemption request has been submitted! The admin will process your rewards shortly.');
    } catch (error) {
      logger.error('Error in redeem rewards action:', error);
      await ctx.reply('Sorry, there was an error. Please try again.');
    }
  });

  // Handle process rewards (admin only)
  bot.action(/^process_rewards_(\d+)$/, async (ctx) => {
    try {
      const userId = parseInt(ctx.match[1]);
      const user = await User.findOne({ userId });

      if (!user) {
        await ctx.answerCbQuery('User not found');
        return;
      }

      const pendingRewards = await AffiliateReward.find({
        userId,
        status: 'pending'
      });

      if (pendingRewards.length === 0) {
        await ctx.answerCbQuery('No pending rewards');
        return;
      }

      const totalAmount = pendingRewards.reduce((sum, reward) => sum + reward.amount, 0);

      const adminMessage = `ðŸ’° Process Rewards for @${user.username || 'N/A'}

Total Amount: ${totalAmount} SOL
Wallet Address: <code>${user.walletAddress}</code>

Click below to confirm payment:`;

      const keyboard = {
        inline_keyboard: [
          [{ text: 'âœ… Confirm Payment', callback_data: `confirm_payment_${userId}` }]
        ]
      };

      await ctx.editMessageText(adminMessage, {
        parse_mode: 'HTML',
        reply_markup: keyboard
      });
    } catch (error) {
      logger.error('Error in process rewards action:', error);
      await ctx.answerCbQuery('Error processing rewards');
    }
  });

  // Handle confirm payment (admin only)
  bot.action(/^confirm_payment_(\d+)$/, async (ctx) => {
    try {
      const userId = parseInt(ctx.match[1]);
      const user = await User.findOne({ userId });

      if (!user) {
        await ctx.answerCbQuery('User not found');
        return;
      }

      const pendingRewards = await AffiliateReward.find({
        userId,
        status: 'pending'
      });

      if (pendingRewards.length === 0) {
        await ctx.answerCbQuery('No pending rewards');
        return;
      }

      const totalAmount = pendingRewards.reduce((sum, reward) => sum + reward.amount, 0);

      // Update rewards status
      await AffiliateReward.updateMany(
        { userId, status: 'pending' },
        { 
          status: 'paid',
          paymentTxId: `PAID_${Date.now()}`,
          updatedAt: new Date()
        }
      );

      // Update user's affiliate stats
      await User.findOneAndUpdate(
        { userId },
        {
          $inc: {
            'affiliateStats.totalEarnings': totalAmount,
            'affiliateStats.pendingEarnings': -totalAmount
          }
        }
      );

      // Notify user
      await ctx.telegram.sendMessage(
        userId,
        `âœ… Your affiliate rewards have been paid!\n\nAmount: ${totalAmount} SOL\nWallet: <code>${user.walletAddress}</code>\n\nThank you for being part of our affiliate program! ðŸŽ‰`,
        { parse_mode: 'HTML' }
      );

      // Update admin message
      await ctx.editMessageText(
        `âœ… Rewards paid successfully!\n\nUser: @${user.username || 'N/A'}\nAmount: ${totalAmount} SOL\nWallet: <code>${user.walletAddress}</code>\n\nPayment completed at: ${new Date().toLocaleString()}`,
        { parse_mode: 'HTML' }
      );

      await ctx.answerCbQuery('Payment confirmed');
    } catch (error) {
      logger.error('Error in confirm payment action:', error);
      await ctx.answerCbQuery('Error confirming payment');
    }
  });
} 